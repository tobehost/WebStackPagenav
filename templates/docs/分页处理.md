这个错误是因为在 Jinja2 模板中，`max` 和 `min` 函数没有在模板上下文中定义。我们需要在模板中提供这些函数或者使用其他方法来实现分页功能。

## 解决方案

### 方案1：在模板上下文中添加 max 和 min 函数

在应用初始化时，将这些函数添加到模板上下文中：

```python
# 在 app/__init__.py 的 create_app 函数中添加

def create_app(config_name='default'):
    app = Flask(__name__,
                template_folder='../templates',
                static_folder='../static')
    
    # ... 其他配置 ...
    
    # 添加内置函数到模板上下文
    @app.context_processor
    def inject_functions():
        return {
            'max': max,
            'min': min,
            'len': len,
            'range': range
        }
    
    # ... 其他代码 ...
    
    return app
```

### 方案2：重写分页逻辑，避免使用 max 和 min

修改分页模板，使用更简单的方法来实现分页：

#### 更新 `templates/admin/model/list.html` 中的分页部分

```html
{% block list_pagination %}
{% if count > admin_view.page_size %}
<nav aria-label="分页导航">
    <ul class="pagination justify-content-center">
        {# 上一页和首页 #}
        {% if page > 1 %}
        <li class="page-item">
            <a class="page-link" href="{{ get_pagination_url(1) }}">首页</a>
        </li>
        <li class="page-item">
            <a class="page-link" href="{{ get_pagination_url(page - 1) }}">上一页</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <a class="page-link" href="#">首页</a>
        </li>
        <li class="page-item disabled">
            <a class="page-link" href="#">上一页</a>
        </li>
        {% endif %}
        
        {# 页码 #}
        {% set start_page = [1, page - 2] | max_custom %}
        {% set end_page = [total_pages, page + 2] | min_custom %}
        
        {% for p in range_custom(start_page, end_page + 1) %}
        <li class="page-item {% if p == page %}active{% endif %}">
            <a class="page-link" href="{{ get_pagination_url(p) }}">{{ p }}</a>
        </li>
        {% endfor %}
        
        {# 下一页和末页 #}
        {% if page < total_pages %}
        <li class="page-item">
            <a class="page-link" href="{{ get_pagination_url(page + 1) }}">下一页</a>
        </li>
        <li class="page-item">
            <a class="page-link" href="{{ get_pagination_url(total_pages) }}">末页</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <a class="page-link" href="#">下一页</a>
        </li>
        <li class="page-item disabled">
            <a class="page-link" href="#">末页</a>
        </li>
        {% endif %}
    </ul>
</nav>
{% endif %}
{% endblock %}
```

### 方案3：创建自定义模板过滤器（推荐）

创建自定义的模板过滤器来处理分页逻辑：

#### 在 `app/__init__.py` 中添加模板过滤器

```python
def create_app(config_name='default'):
    app = Flask(__name__,
                template_folder='../templates',
                static_folder='../static')
    
    # ... 其他配置 ...
    
    # 自定义模板过滤器
    @app.template_filter()
    def max_custom(values):
        """返回列表中的最大值"""
        return max(values)
    
    @app.template_filter()
    def min_custom(values):
        """返回列表中的最小值"""
        return min(values)
    
    @app.template_filter()
    def range_custom(start, end):
        """生成范围内的数字列表"""
        return list(range(start, end))
    
    # 添加上下文处理器
    @app.context_processor
    def utility_processor():
        def get_pagination_url(page_num):
            """生成分页URL"""
            from flask import request
            args = request.args.copy()
            args['page'] = page_num
            return '{}?{}'.format(request.path, '&'.join([f'{k}={v}' for k, v in args.items()]))
        
        return {
            'get_pagination_url': get_pagination_url,
            'max_custom': max,
            'min_custom': min,
            'range_custom': range
        }
    
    # ... 其他代码 ...
    
    return app
```

### 方案4：完整的修复版本（推荐使用）

创建一个专门的分页宏文件，并在模板中包含它：

#### 创建 `templates/admin/macros/pagination.html`

```html
{% macro render_pagination(pagination, endpoint) %}
{% if pagination.pages > 1 %}
<nav aria-label="分页导航">
    <ul class="pagination justify-content-center">
        {# 上一页 #}
        {% if pagination.has_prev %}
        <li class="page-item">
            <a class="page-link" href="{{ url_for(endpoint, page=pagination.prev_num, **kwargs) }}">上一页</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <span class="page-link">上一页</span>
        </li>
        {% endif %}
        
        {# 页码 #}
        {%- for page in pagination.iter_pages() %}
            {% if page %}
                {% if page != pagination.page %}
                <li class="page-item">
                    <a class="page-link" href="{{ url_for(endpoint, page=page, **kwargs) }}">{{ page }}</a>
                </li>
                {% else %}
                <li class="page-item active">
                    <span class="page-link">{{ page }}</span>
                </li>
                {% endif %}
            {% else %}
                <li class="page-item disabled">
                    <span class="page-link">…</span>
                </li>
            {% endif %}
        {%- endfor %}
        
        {# 下一页 #}
        {% if pagination.has_next %}
        <li class="page-item">
            <a class="page-link" href="{{ url_for(endpoint, page=pagination.next_num, **kwargs) }}">下一页</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <span class="page-link">下一页</span>
        </li>
        {% endif %}
    </ul>
</nav>
{% endif %}
{% endmacro %}
```

#### 更新 `templates/admin/model/list.html`

```html
{% extends 'admin/base.html' %}

{% block body %}
<div class="container-fluid">
    <div class="card">
        <div class="card-header">
            <div class="d-flex justify-content-between align-items-center">
                <h4 class="card-title mb-0">
                    <i class="fas fa-list"></i>
                    {{ admin_view.name }}列表
                </h4>
                <div>
                    {% if admin_view.can_create %}
                    <a href="{{ url_for('.create_view') }}" class="btn btn-success btn-sm">
                        <i class="fas fa-plus"></i> 添加{{ admin_view.name }}
                    </a>
                    {% endif %}
                </div>
            </div>
        </div>
        
        <div class="card-body">
            {% block list_table %}
            <div class="table-responsive">
                <table class="table table-striped table-hover">
                    <thead>
                        <tr>
                            {% for column in admin_view.column_list %}
                            <th>{{ admin_view.column_labels.get(column, column) }}</th>
                            {% endfor %}
                            <th>操作</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for model in data %}
                        <tr>
                            {% for column in admin_view.column_list %}
                            <td>
                                {% set value = get_value(model, column) %}
                                {{ value }}
                            </td>
                            {% endfor %}
                            <td>
                                <div class="btn-group btn-group-sm">
                                    {% if admin_view.can_view_details %}
                                    <a href="{{ url_for('.details_view', id=model.id) }}" 
                                       class="btn btn-info" title="查看详情">
                                        <i class="fas fa-eye"></i>
                                    </a>
                                    {% endif %}
                                    {% if admin_view.can_edit %}
                                    <a href="{{ url_for('.edit_view', id=model.id) }}" 
                                       class="btn btn-primary" title="编辑">
                                        <i class="fas fa-edit"></i>
                                    </a>
                                    {% endif %}
                                    {% if admin_view.can_delete %}
                                    <a href="{{ url_for('.delete_view', id=model.id) }}" 
                                       class="btn btn-danger" title="删除"
                                       onclick="return confirm('确定要删除这条记录吗？');">
                                        <i class="fas fa-trash"></i>
                                    </a>
                                    {% endif %}
                                </div>
                            </td>
                        </tr>
                        {% else %}
                        <tr>
                            <td colspan="{{ admin_view.column_list|length + 1 }}" class="text-center text-muted">
                                {{ admin_view.get_empty_list_message() }}
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
            {% endblock %}
            
            {% block list_pagination %}
            {# 使用Flask-SQLAlchemy的分页对象 #}
            {% if pagination %}
                {% from "admin/macros/pagination.html" import render_pagination %}
                {{ render_pagination(pagination, '.index_view') }}
            {% endif %}
            {% endblock %}
        </div>
    </div>
</div>
{% endblock %}

{% macro get_value(model, field) %}
    {% set value = model[field] %}
    {% if value is iterable and value is not string %}
        {{ value | join(', ') }}
    {% elif value is boolean %}
        {% if value %}
            <span class="badge bg-success">是</span>
        {% else %}
            <span class="badge bg-secondary">否</span>
        {% endif %}
    {% elif field == 'created_at' or field == 'updated_at' %}
        {{ value.strftime('%Y-%m-%d %H:%M') if value else '' }}
    {% elif field == 'description' and value %}
        {{ value[:50] }}{% if value|length > 50 %}...{% endif %}
    {% else %}
        {{ value or '' }}
    {% endif %}
{% endmacro %}
```

### 方案5：简化版本（如果以上方案都太复杂）

直接在模板中硬编码分页逻辑：

```html
<ul class="pagination justify-content-center">
    {# 上一页 #}
    {% if page > 1 %}
    <li class="page-item">
        <a class="page-link" href="?page=1">首页</a>
    </li>
    <li class="page-item">
        <a class="page-link" href="?page={{ page - 1 }}">上一页</a>
    </li>
    {% else %}
    <li class="page-item disabled">
        <a class="page-link" href="#">首页</a>
    </li>
    <li class="page-item disabled">
        <a class="page-link" href="#">上一页</a>
    </li>
    {% endif %}
    
    {# 页码 - 简化版本，只显示前后各2页 #}
    {% for p in [page-2, page-1, page, page+1, page+2] %}
        {% if p >= 1 and p <= total_pages %}
        <li class="page-item {% if p == page %}active{% endif %}">
            <a class="page-link" href="?page={{ p }}">{{ p }}</a>
        </li>
        {% endif %}
    {% endfor %}
    
    {# 下一页 #}
    {% if page < total_pages %}
    <li class="page-item">
        <a class="page-link" href="?page={{ page + 1 }}">下一页</a>
    </li>
    <li class="page-item">
        <a class="page-link" href="?page={{ total_pages }}">末页</a>
    </li>
    {% else %}
    <li class="page-item disabled">
        <a class="page-link" href="#">下一页</a>
    </li>
    <li class="page-item disabled">
        <a class="page-link" href="#">末页</a>
    </li>
    {% endif %}
</ul>
```

## 推荐解决方案

我推荐使用**方案4**，因为它：

1. 使用了 Flask-SQLAlchemy 的标准分页对象
2. 创建了可重用的分页宏
3. 代码清晰且易于维护
4. 遵循了 Flask 和 Jinja2 的最佳实践

选择最适合您项目复杂度和需求的方案即可。